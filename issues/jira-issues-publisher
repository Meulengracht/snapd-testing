#!/usr/bin/env python3

import argparse
import logging
import os
import pytz
import re
import requests
import sys
import yaml

from datetime import datetime, timedelta
from jira import JIRA
from jira.client import ResultList
from jira.resources import Issue
from jira.exceptions import JIRAError

JIRA_URL = 'https://warthogs.atlassian.net'
PROJECT_ID = 'ST'
ISSUES_LANE = 'ISSUES'
SYSTEMS_CHECKLIST = 'Reproduced in Systems'

def _make_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('--token', help="OAuth access token for the user",
                        **environ_or_required('JIRA_ACCESS_TOKEN'))
    parser.add_argument('--token-secret', help="OAuth access token secret to sign with the key",
                        **environ_or_required('JIRA_ACCESS_TOKEN_SECRET'))
    parser.add_argument('--key-cert', help="Private key file to sign requests with",
                        **environ_or_required('JIRA_KEY_CERT'))
  
    # Subparsers definition
    subparser = parser.add_subparsers(help='commands', dest='command')
    parser_create = subparser.add_parser("create")
    parser_create.add_argument('-t', '--title', help="issue title", required=True)
    parser_create.add_argument('-s', '--system', help="system where it is reproduced", action='append', required=True)
    parser_create.add_argument('-o', '--ocurrencies', help="number of times the issue has been reproduced", default=0, type=int, choices=range(0, 5000))

    parser_show = subparser.add_parser("show")
    parser_show.add_argument('-t', '--title', help="issue title", required=True)

    return parser


def environ_or_required(key):
    if os.environ.get(key):
        return {'default': os.environ.get(key)}
    else:
        return {'required': True}


class JiraManager:
    def __init__(self, access_token, access_token_secret, key_cert):
        self.client = self._get_client(access_token, access_token_secret, key_cert)
        self.project_id = PROJECT_ID

    def _get_client(self, access_token, access_token_secret, key_cert):
        cert_data = key_cert
        if os.path.exists(key_cert): 
            with open(key_cert, 'r') as file:
                cert_data = file.read()

        return JIRA(
            oauth=dict(
                access_token=access_token, 
                access_token_secret=access_token_secret, 
                consumer_key="OauthKey", 
                key_cert=cert_data),
            server=JIRA_URL)

    def get_all_cards(self):
        return self.client.search_issues("project = {}".format(self.project_id))

    def search_cards(self, title):
        return self.client.search_issues("project = {} AND summary ~ '{}'".format(self.project_id, title))

    def search_cards_on_list(self, title, lane):
        return self.client.search_issues("project = {} AND summary ~ '{}' AND status = {}".format(self.project_id, query, lane))

    def search(self, title):
        cards = self.search_cards(title)

        for card in cards:
            if card.fields.summary == title:
                return card

        if cards:
            if len(cards) > 1:
                raise RuntimeError('More than 1 card found but not cards with title: "{}"'.format(title))
        else:
            return None

        return cards[0] 

    def search_by_key(self, key):
        cards = self.client.search_issues("project = {} AND key = '{}'".format(self.project_id, key))
        if not cards:
            raise RuntimeError('No cards found with title "{}"'.format(title))
        
        return cards[0]

    def show(self, title):
        cards = self.search(title)
        if not cards:
            raise RuntimeError('No cards found with title "{}"'.format(title))

        if len(cards) > 1:
            raise RuntimeError('More than 1 card found for title: "{}"'.format(title))
        
        card = cards[0]
        print('id: {}'.format(card.key))
        print('name: {}'.format(card.fields.summary))
        print('desc: {}'.format(card.fields.description))
        print('list: {}'.format(card.fields.status))

        comments = self.client.comments(card)
        print('comments')
        for comment in comments:
            print('  ' + comment.id + ': ' + comment.body)

        yaml_dict = yaml.safe_load(card.fields.customfield_10038)
        print(card.fields.customfield_10038)

        ocurrencies_manager = OcurrenciesManager(card)
        print('ocurrencies: {}'.format(ocurrencies_manager.get_ocurrencies()))


    def _create_card(self, title):
        fields = dict()
        fields['project']=PROJECT_ID
        fields['issuetype']={'name': 'Bug'}
        fields['summary']=title
        return self.client.create_issue(fields)

    def create(self, title, systems, ocurrencies, lane=ISSUES_LANE):
        card = self.search(title)
        if not card:
            card = self._create_card(title)
            if not card:
                raise RuntimeError('The card with title "{}" cannot be created'.format(title))

        self._move_card(card, lane)

        for system in systems:
            checklist_manager = ChecklistManager(card)
            checklist_manager.merge_checklist(SYSTEMS_CHECKLIST, systems, checked=True)

        if not ocurrencies:
            ocurrencies = len(systems)

        ocurrencies_manager = OcurrenciesManager(card)
        last_ocurrencies = ocurrencies_manager.get_ocurrencies()
        new_ocurrencies = last_ocurrencies + ocurrencies
        ocurrencies_manager.set_ocurrencies(new_ocurrencies)


    def _move_card(self, card, lane):
        transitions = self.client.transitions(card.key)
        for transition in transitions:
            if transition.get('name').capitalize() == lane.capitalize():
                self.client.transition_issue(card, transition.get('id'))
                return

        raise RuntimeError('The list {} does not exist'.format(lane))

    def _find_or_create_card(self, title, lane=ISSUES_LANE):
        card = self.search(title)
        if card:
            return card

        card = self._create_card(title, lane)
        if not card:
            raise RuntimeError('The card with title "{}" cannot be created'.format(title))            

        return card

    def delete(self, title):
        card = self.search(title)
        if not card:
            print('error:card does not exist')
            return
        card.delete()
        print('card deleted: {}'.format(card.key))


    def attach(self, title, name, file):
        card = self.search(title)
        if not card:
            raise RuntimeError('The card with title "{}" does not exist'.format(title))

        if not os.path.exists(file):
            raise RuntimeError('The file "{}"" does not exist'.format(file))
        
        with open(file, "rb") as f:
            self.client.add_attachment(issue=card, attachment=f, filename=name)

class OcurrenciesManager:
    def __init__(self, card):
        self.card = card
    
    def get_ocurrencies(self):
        ocurrencies_field = self.card.fields.customfield_10122
        if not ocurrencies_field:
            raise RuntimeError('The card {} has not an ocurrencies field'.format(this.card.key))

        return int(ocurrencies_field)

    def set_ocurrencies(self, ocurrencies):
        fields=dict()
        fields['customfield_10122'] = ocurrencies
        self.card.update(fields)


class ChecklistManager:
    def __init__(self, card):
        self.card = card

    def get_all_checklists(self):
        checklist_field = self.card.fields.customfield_10038
        if not checklist_field:
            return []

        checklist = yaml.safe_load(checklist_field).get('items')
        if not checklist:
            return []

        return checklist

    def get_checklist(self, checklist_name):
        checklist = self.get_all_checklists()

        new_checklists = []
        found = False
        for checklist_item in checklist:
            # Either not found the checklist to update or it was already copied and a new checklist started
            if not found:
                # When the checklist is found, the values on items are used
                if checklist_item.get('text') == '---{}'.format(checklist_name):
                    found = True
                    new_checklists.append(checklist_item)
                # Values of a checklist must be added to the new one
                else:
                    continue
            # Still iterating elements of the checklist to update
            else:
                # A new checklist starts
                if checklist_item.get('text').startswith('---'):
                    break
                else:
                    new_checklists.append(checklist_item)

        return new_checklists

    def is_checklist_item_checked(self, checklist_name, checklist_item):
        checklist = self.get_checklist(checklist_name)
        if not checklist:
            raise RuntimeError('checklist {} does not exist in card {}'.format(checklist_name, self.card.key))

        for item in checklist:
            if item.get('text') == checklist_item:
                if item.get('checked'):
                    return True
                else:
                    return False

        raise RuntimeError('checklist item {} does not exist in checklist {}'.format(checklist_item, checklist_name))


    def is_checklist(self, checklist_name):
        checklist = self.get_checklist(checklist_name)
        if not checklist:
            return False

        for item in checklist:
            if item.get('text') == '---{}'.format(checklist_name):
                return True

        return False

    def _merge_checklist(self, initial_checklist, values=[], checked=True):
        new_checklist = initial_checklist.copy()
        for value in values:
            found = False
            for checklist_item in initial_checklist:
                if checklist_item.get('text') == value:
                    found = True
                    break
            if not found:
                new_checklist.append({'text': value, 'checked': checked})
        return new_checklist


    def merge_checklist(self, checklist_name, values=[], checked=True):
        all_checklists = self.get_all_checklists()
        new_checklists = []
        new_checklist = self.create_checklist(checklist_name, values, checked)

        # Either no checklists in the card or the checklist is not added
        if not all_checklists or not self.is_checklist(checklist_name):
            all_checklists = self._add_checklist(all_checklists, new_checklist)
        # The checklist already exits
        else:
            initial_checklist = self.get_checklist(checklist_name)
            without_checklist = self._remove_checklist(all_checklists, checklist_name)
            merged_checklist = self._merge_checklist(initial_checklist, values, checked)
            all_checklists = self._add_checklist(without_checklist, merged_checklist)

        self._save_checklist(all_checklists)

    def create_checklist(self, checklist_name, values, checked=True):
        checklist = []
        checklist.append({'text': '---{}'.format(checklist_name), 'checked': False})
        for value in values:
            checklist.append({'text': value, 'checked': checked})
        
        return checklist

    ### Add a checklist to the end of the all_checklists
    def _add_checklist(self, all_checklists, new_checklist):
        all_checklists.extend(new_checklist)        
        return all_checklists

    ### Remove the checklist from all_checklist and return the rest of the checklists
    def _remove_checklist(self, all_checklist, checklist_name):
        new_checklists = []
        found = False
        for checklist_item in all_checklist:
            # Not inside the checklist
            if not found:
                # the checklist to remove starts
                if checklist_item.get('text') == '---{}'.format(checklist_name):
                    found = True
                    continue
                # a new value to add
                else:
                    new_checklists.append(checklist_item)
            # Inside the checklist
            else:
                # New checklist starts
                if checklist_item.get('text').startswith('---'):
                    new_checklists.append(checklist_item)
                # New idem of the checklist
                else:
                    continue

        return new_checklists


    def _save_checklist(self, checklist):
        text = yaml.dump(dict(items=checklist))
        fields=dict()
        fields['customfield_10038']=text
        self.card.update(fields)


def main():
    parser = _make_parser()
    args = parser.parse_args()

    jira = JiraManager(args.token, args.token_secret, args.key_cert)

    if args.command == 'create':
        jira.create(args.title, args.system, args.ocurrencies)

    if args.command == 'show':
        jira.show(args.title)

    if args.command == 'delete':
        jira.delete(args.title)

    if args.command == 'attach':
        jira.attach(args.title, args.file)


if __name__ == "__main__":
    main()
